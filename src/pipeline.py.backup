import itertools
import logging
from pathlib import Path
import os, math, time

import cv2, numpy as np

from utils import (
    Hough,
    Position,
    Vector,
    imread_unicode,
    imwrite_unicode,
    get_memory_usage_mb,
    force_garbage_collection,
    SUPPORTED_EXTS,
)

from algorithms_circle import Circle, detect_circle_phd2_enhanced, masked_phase_corr
from version import VERSION

# refine è¿”å›å¯èƒ½æ˜¯ (M, score, nin) ä¹Ÿå¯èƒ½æ˜¯ (M, theta_deg, score, nin)
from algorithms_refine import refine_alignment_multi_roi  # å…¼å®¹æ—§/æ–°ç­¾å
from numpy.typing import NDArray


# ------------------ è°ƒè¯•å›¾ä¿å­˜ ------------------
def save_debug_image(
    processed_img: NDArray,
    target_center: Position[float],
    reference_center: Position[float],
    shift: Vector[float],
    confidence,
    method,
    debug_dir: Path,
    filename,
    reference_filename,
):
    try:
        if processed_img is None:
            return
        if processed_img.ndim == 2:
            debug_image = cv2.cvtColor(processed_img, cv2.COLOR_GRAY2BGR)
        else:
            debug_image = processed_img.copy()
        cv2.circle(
            debug_image,
            (int(target_center.x), int(target_center.y)),
            5,
            (0, 0, 255),
            -1,
        )
        cv2.circle(
            debug_image,
            (int(reference_center.x), int(reference_center.y)),
            15,
            (0, 255, 255),
            3,
        )
        cv2.line(
            debug_image,
            (int(target_center.x), int(target_center.y)),
            (int(reference_center.x), int(reference_center.y)),
            (0, 255, 255),
            2,
        )
        font = cv2.FONT_HERSHEY_SIMPLEX
        texts = [
            f"Method: {method[:35]}",
            f"Shift: ({shift.x:.1f}, {shift.y:.1f})",
            f"Confidence: {confidence:.3f}",
            f"Reference: {reference_filename}",
            f"Mode: Incremental Processing",
        ]
        for j, t in enumerate(texts):
            cv2.putText(
                debug_image, t, (10, 25 + j * 25), font, 0.6, (255, 255, 255), 2
            )
        debug_path = debug_dir / f"debug_{filename}"
        imwrite_unicode(debug_path, debug_image)
    except Exception as e:
        print(f"è°ƒè¯•å›¾åƒç”Ÿæˆå¤±è´¥: {e}")


# ------------------ ç¼©ç•¥å›¾è¾…åŠ© ------------------
def _detect_circle_on_thumb(
    img: np.ndarray, hough: Hough, max_side=1600, strong_denoise=False
) -> tuple[Circle, float, float, str]:
    """
    Returns:
    - Circle: (cx, cy, radius) in original image scale
    - scale: float, the scale factor from original to thumbnail
    - quality: float, quality score of the detected circle
    - method: str, description of the detection method used
    Raises Exception if detection fails
    ä»…ç”¨äºè¾…åŠ©é€‰æ‹©å‚è€ƒå›¾åƒ
    """
    H, W = img.shape[:2]
    max_wh = max(H, W)
    scale = 1.0
    if max_wh > max_side:
        scale = max_side / float(max_wh)
    small = (
        cv2.resize(img, (int(W * scale), int(H * scale)), interpolation=cv2.INTER_AREA)
        if scale < 1.0
        else img
    )

    s_hough = Hough(
        minRadius=max(1, int(hough.minRadius * scale)),
        maxRadius=max(
            2, int(hough.minRadius * scale) + 1, int(hough.maxRadius * scale)
        ),
        param1=hough.param1,
        param2=hough.param2,
    )
    t0 = time.time()
    circle_s, _, quality_s, method_s, _ = detect_circle_phd2_enhanced(
        small, s_hough, strong_denoise=strong_denoise
    )
    dt = time.time() - t0

    if circle_s is None:
        raise Exception("ç¼©ç•¥å›¾åœ†æ£€æµ‹å¤±è´¥")

    circle = Circle(
        x=float(circle_s.x / scale),
        y=float(circle_s.y / scale),
        radius=float(circle_s.radius / scale),
    )
    return (
        circle,
        scale,
        quality_s,
        f"{method_s}(thumb,{small.shape[1]}x{small.shape[0]}, {dt:.2f}s)",
    )


# ------------------ ä¸»æµç¨‹ ------------------


def align_moon_images_incremental(
    input_dir: Path,
    output_dir: Path,
    hough: Hough,
    log_box=None,
    debug_mode=False,
    debug_image_basename="",
    completion_callback=None,
    progress_callback=None,
    reference_image_path=None,
    use_advanced_alignment=False,
    alignment_method="auto",
    strong_denoise=False,
):
    try:

        try:
            output_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            raise Exception(f"æ— æ³•åˆ›å»ºè¾“å‡ºæ–‡ä»¶å¤¹: {output_dir}") from e

        debug_dir = output_dir / "debug"
        if debug_mode:
            try:
                debug_dir.mkdir(parents=True, exist_ok=True)
            except Exception as e:
                raise Exception(f"æ— æ³•åˆ›å»ºè°ƒè¯•æ–‡ä»¶å¤¹: {debug_dir}") from e

        try:
            image_files = sorted(
                itertools.chain.from_iterable(
                    input_dir.glob(ext) for ext in SUPPORTED_EXTS
                )
            )
        except Exception as e:
            raise Exception(f"è¯»å–è¾“å…¥æ–‡ä»¶å¤¹å¤±è´¥: {e}")

        if not image_files:
            raise Exception(f"åœ¨ '{input_dir}' ä¸­æœªæ‰¾åˆ°æ”¯æŒçš„å›¾ç‰‡æ–‡ä»¶")

        input_files_num = len(image_files)

        logging.info(f"æœˆé£Ÿåœ†é¢å¯¹é½å·¥å…· V{VERSION} - å¢é‡å¤„ç†ç‰ˆ")
        logging.info(f"å¤„ç†æ¨¡å¼: å¢é‡å¤„ç† (è¾¹æ£€æµ‹è¾¹ä¿å­˜)")
        logging.info(f"æ–‡ä»¶æ€»æ•°: {input_files_num}")
        logging.info(f"å¤šROIç²¾é…å‡†: {'å¯ç”¨' if use_advanced_alignment else 'ç¦ç”¨'}")

        # å‚è€ƒå›¾åƒ
        logging.info("é˜¶æ®µ 1/2: ç¡®å®šå‚è€ƒå›¾åƒ...")
        reference_image = None
        reference_circle: Circle | None = None
        reference_filename = None
        best_quality = 0.0
        reference_radius = None

        # ---------- ç”¨æˆ·æŒ‡å®šå‚è€ƒå›¾ ----------
        if reference_image_path and os.path.exists(reference_image_path):
            ref_filename = os.path.basename(reference_image_path)
            logging.info(f"åŠ è½½ç”¨æˆ·æŒ‡å®šçš„å‚è€ƒå›¾åƒ: {ref_filename}")

            t_ref0 = time.time()
            ref_img = imread_unicode(reference_image_path, cv2.IMREAD_UNCHANGED)
            if ref_img is not None:
                H, W = ref_img.shape[:2]
                logging.info(f"å‚è€ƒå›¾å°ºå¯¸: {W}x{H}")

                # å…ˆåœ¨ç¼©ç•¥å›¾åšï¼Œæ˜ å°„å›åŸå›¾
                try:
                    circle, scale, q, meth = _detect_circle_on_thumb(
                        ref_img, hough, max_side=1600, strong_denoise=strong_denoise
                    )

                    reference_image = ref_img.copy()
                    reference_circle = circle
                    reference_filename = ref_filename
                    best_quality = q
                    logging.info(
                        f"âœ“ å‚è€ƒå›¾åƒæ£€æµ‹æˆåŠŸ: è´¨é‡={q:.1f}, æ–¹æ³•={meth}, åŠå¾„â‰ˆ{reference_radius:.1f}px"
                    )
                except Exception as e:
                    logging.info(
                        "ç¼©ç•¥å›¾æ£€æµ‹å¤±è´¥ï¼Œå›é€€åˆ°åŸå›¾åšä¸€æ¬¡åœ†æ£€æµ‹ï¼ˆå¯èƒ½è¾ƒæ…¢ï¼‰..."
                    )
                    t1 = time.time()
                    circle_full, _, qf, mf, _ = detect_circle_phd2_enhanced(
                        ref_img, hough, strong_denoise=strong_denoise
                    )
                    dt1 = time.time() - t1
                    if circle_full is not None:
                        reference_image = ref_img.copy()
                        reference_circle = circle_full
                        reference_filename = ref_filename
                        best_quality = float(qf)
                        logging.info(
                            f"âœ“ å‚è€ƒå›¾åƒæ£€æµ‹æˆåŠŸ: è´¨é‡={best_quality:.1f}, æ–¹æ³•={mf}, åŠå¾„â‰ˆ{reference_radius:.1f}px, ç”¨æ—¶ {dt1:.2f}s"
                        )
                    else:
                        logging.info("âœ— å‚è€ƒå›¾åƒæ£€æµ‹å¤±è´¥ï¼Œå°†è‡ªåŠ¨é€‰æ‹©")
            else:
                logging.info("âœ— å‚è€ƒå›¾åƒè¯»å–å¤±è´¥ï¼Œå°†è‡ªåŠ¨é€‰æ‹©")

        # ---------- è‡ªåŠ¨æ‰«æå‰ N å¼  ----------
        if reference_image is None:
            scan_count = min(10, input_files_num)
            logging.info(f"è‡ªåŠ¨é€‰æ‹©å‚è€ƒå›¾åƒ (æ‰«æå‰{scan_count}å¼ )...")
            for i, filename in enumerate(image_files[:scan_count]):
                if progress_callback:
                    progress_callback(
                        int((i / scan_count) * 20), f"æ‰«æå‚è€ƒå›¾åƒ: {filename}"
                    )
                input_path = input_dir / filename
                img0 = imread_unicode(input_path, cv2.IMREAD_UNCHANGED)
                if img0 is None:
                    continue
                try:
                    circle, scale, q, meth = _detect_circle_on_thumb(
                        img0, hough, max_side=1600, strong_denoise=strong_denoise
                    )
                    if q > best_quality:
                        reference_image = img0.copy()
                        reference_circle = circle
                        reference_filename = filename
                        best_quality = q
                        reference_radius = circle.radius
                        logging.info(
                            f"  å€™é€‰å‚è€ƒå›¾åƒ: {filename}, è´¨é‡={q:.1f}, æ–¹æ³•={meth}"
                        )
                except Exception as e:
                    pass
                del img0
                force_garbage_collection()

        if reference_image is None:
            raise Exception("æ— æ³•æ‰¾åˆ°æœ‰æ•ˆçš„å‚è€ƒå›¾åƒï¼Œè¯·æ£€æŸ¥å›¾åƒè´¨é‡å’Œå‚æ•°è®¾ç½®")

        logging.info(
            f"ğŸ¯ æœ€ç»ˆå‚è€ƒå›¾åƒ: {reference_filename}, è´¨é‡è¯„åˆ†={best_quality:.1f}"
        )

        # å¤„ç†æ‰€æœ‰å›¾åƒ
        logging.info(f"\né˜¶æ®µ 2/2: å¢é‡å¤„ç†æ‰€æœ‰å›¾åƒ...")
        success_count = 0
        failed_files = []
        brightness_stats = {"bright": 0, "normal": 0, "dark": 0}
        method_stats = {}

        # ä»¥å‚è€ƒå›¾åœ†ä½œä¸ºå…ˆéªŒï¼Œåç»­é€å¸§æ›´æ–°
        assert reference_circle is not None
        last_circle: Circle | None = reference_circle
        for i, filename in enumerate(image_files):
            if progress_callback:
                progress_callback(
                    20 + int((i / input_files_num) * 80), f"å¤„ç†: {filename}"
                )
            try:
                input_path = input_dir / filename

                # å‚è€ƒå›¾ï¼šç›´æ¥å¦å­˜
                if filename == reference_filename:
                    output_path = output_dir / f"aligned_{filename}"
                    if imwrite_unicode(output_path, reference_image):
                        success_count += 1
                        logging.info(f"  ğŸ¯ {filename}: [å‚è€ƒå›¾åƒ] å·²ä¿å­˜")
                        if debug_mode and filename == debug_image_basename:
                            save_debug_image(
                                reference_image,
                                reference_circle,
                                reference_circle,
                                Vector(0, 0),
                                1.0,
                                "Reference Image",
                                output_dir / "debug",
                                filename,
                                reference_filename,
                            )
                    else:
                        logging.info(f"  âœ— {filename}: ä¿å­˜å¤±è´¥")
                        failed_files.append(filename)
                    continue

                # è¯»å–ç›®æ ‡
                t_read = time.time()
                target_image: NDArray | None = imread_unicode(
                    input_path, cv2.IMREAD_UNCHANGED
                )
                if target_image is None:
                    logging.info(f"  âœ— {filename}: è¯»å–å¤±è´¥")
                    failed_files.append(filename)
                    continue
                dt_read = time.time() - t_read

                # åœ†æ£€æµ‹
                t_det = time.time()
                circle, processed, quality, method, brightness = (
                    detect_circle_phd2_enhanced(
                        target_image,
                        hough,
                        strong_denoise=strong_denoise,
                        prev_circle=last_circle,
                    )
                )
                dt_det = time.time() - t_det

                if circle is None:
                    logging.info(f"  âœ— {filename}: åœ†æ£€æµ‹å¤±è´¥(è€—æ—¶ {dt_det:.2f}s)")
                    failed_files.append(filename)
                    del target_image
                    continue

                brightness_stats[brightness] += 1
                method_stats[method] = method_stats.get(method, 0) + 1

                target_center = circle

                # åˆå§‹ï¼šåœ†å¿ƒå¹³ç§»åˆ°å‚è€ƒ
                shift = reference_circle - circle

                confidence: float = max(0.30, min(0.98, quality / 100.0))
                align_method = "Circle Center"

                rows, cols = target_image.shape[:2]
                M = np.array([[1, 0, shift.x], [0, 1, shift.y]], dtype=np.float64)

                aligned: NDArray = cv2.warpAffine(
                    target_image,
                    M,
                    (cols, rows),
                    flags=cv2.INTER_LANCZOS4,
                    borderMode=cv2.BORDER_CONSTANT,
                    borderValue=0,
                )

                # å¤š ROI ç²¾é…å‡†ï¼ˆä»…å¹³ç§»ï¼Œæ— æ—‹è½¬ï¼‰
                try:
                    if reference_radius is not None and use_advanced_alignment:
                        ref_gray = (
                            reference_image
                            if reference_image.ndim == 2
                            else cv2.cvtColor(reference_image, cv2.COLOR_BGR2GRAY)
                        )
                        tgt_gray2 = (
                            aligned
                            if aligned.ndim == 2
                            else cv2.cvtColor(aligned, cv2.COLOR_BGR2GRAY)
                        )

                        roi_size = max(64, min(160, int(reference_radius * 0.18)))
                        max_refine_delta_px = 6.0
                        t_refine = time.time()
                        M2x3, score, n_inliers, theta_deg = refine_alignment_multi_roi(
                            ref_gray,
                            tgt_gray2,
                            reference_circle,
                            n_rois=16,
                            roi_size=roi_size,
                            search=12,
                            use_phasecorr=True,
                            use_ecc=False,
                            base_shift=shift,
                            max_refine_delta_px=max_refine_delta_px,
                        )
                        dt_refine = time.time() - t_refine

                        roi_used = roi_size
                        logging.info(
                            f"    [Refine] score={score:.3f}, inliers={n_inliers}, roi_initâ‰ˆ{roi_used}, t={dt_refine:.2f}s"
                        )
                        residual = None
                        if M2x3 is not None:
                            tx = float(M2x3[0, 2])
                            ty = float(M2x3[1, 2])
                            residual = (tx**2 + ty**2) ** 0.5
                            logging.info(f"    [Refine] æ®‹å·®=Î”{residual:.2f}px")
                            if residual > max_refine_delta_px:
                                M2 = None
                                logging.info(
                                    f"    [Refine] æ®‹å·®è¿‡å¤§(Î”={residual:.2f}px > {max_refine_delta_px:.1f}px)ï¼Œæ”¾å¼ƒç²¾é…å‡†å¹¶ä¿æŒéœå¤«å¹³ç§»"
                                )
                        if M2x3 is not None:
                            aligned = cv2.warpAffine(
                                aligned,
                                M2x3,
                                (cols, rows),
                                flags=cv2.INTER_LANCZOS4,
                                borderMode=cv2.BORDER_CONSTANT,
                                borderValue=0,
                            )
                            confidence = max(confidence, float(score))
                            align_method = f"Multi-ROI refine (ä»…å¹³ç§», inliers={n_inliers}, roi_initâ‰ˆ{roi_used}, Î”={residual:.2f}px, gateâ‰¤{max_refine_delta_px:.0f}px, {dt_refine:.2f}s)"
                        else:
                            logging.info("    [Refine] æ— æœ‰æ•ˆè§£ï¼Œå›é€€ Masked PhaseCorr")
                            # é®ç½©ç›¸ä½ç›¸å…³å¾®è°ƒï¼ˆä»…å¹³ç§»ï¼‰
                            t_pc = time.time()
                            d2 = masked_phase_corr(
                                ref_gray,
                                tgt_gray2,
                                reference_circle,
                            )
                            dt_pc = time.time() - t_pc
                            if abs(d2.x) > 1e-3 or abs(d2.y) > 1e-3:
                                M2 = np.array(
                                    [[1, 0, d2.x], [0, 1, d2.y]], dtype=np.float32
                                )
                                aligned = cv2.warpAffine(
                                    aligned,
                                    M2,
                                    (cols, rows),
                                    flags=cv2.INTER_LANCZOS4,
                                    borderMode=cv2.BORDER_CONSTANT,
                                    borderValue=0,
                                )
                                align_method = f"Masked PhaseCorr ({dt_pc:.2f}s)"
                    elif reference_radius is not None:
                        # æœªå¯ç”¨é«˜çº§ï¼šé®ç½©ç›¸ä½ç›¸å…³å¾®è°ƒ
                        ref_gray = (
                            reference_image
                            if reference_image.ndim == 2
                            else cv2.cvtColor(reference_image, cv2.COLOR_BGR2GRAY)
                        )
                        tgt_gray2 = (
                            aligned
                            if aligned.ndim == 2
                            else cv2.cvtColor(aligned, cv2.COLOR_BGR2GRAY)
                        )
                        d2 = masked_phase_corr(
                            ref_gray,
                            tgt_gray2,
                            reference_circle,
                        )
                        if abs(d2.x) > 1e-3 or abs(d2.y) > 1e-3:
                            M2 = np.array(
                                [[1, 0, d2.x], [0, 1, d2.y]], dtype=np.float32
                            )
                            aligned = cv2.warpAffine(
                                aligned,
                                M2,
                                (cols, rows),
                                flags=cv2.INTER_LANCZOS4,
                                borderMode=cv2.BORDER_CONSTANT,
                                borderValue=0,
                            )
                            align_method = "Masked PhaseCorr"
                except Exception as e:
                    logging.info(f"    [Refineå¼‚å¸¸] {filename}: {e}")

                # ä¿å­˜
                out_path = output_dir / f"aligned_{filename}"
                if imwrite_unicode(out_path, aligned):
                    success_count += 1
                    # æ›´æ–°ä¸Šä¸€å¸§å…ˆéªŒ
                    try:
                        last_circle = circle
                    except Exception:
                        pass
                    logging.info(
                        f"  âœ“ {filename}: åç§»=({shift.x:.1f},{shift.y:.1f}), "
                        f"è´¨é‡={quality:.1f}, ç½®ä¿¡åº¦={confidence:.3f}, åœ†æ£€è€—æ—¶={dt_det:.2f}s, è¯»å–={dt_read:.2f}s | {align_method}"
                    )

                    if (
                        debug_mode
                        and filename == debug_image_basename
                        and processed is not None
                    ):
                        save_debug_image(
                            processed,
                            target_center,
                            reference_circle,
                            shift,
                            confidence,
                            align_method,
                            debug_dir,
                            filename,
                            reference_filename,
                        )
                else:
                    logging.info(f"  âœ— {filename}: å˜æ¢æˆåŠŸä½†ä¿å­˜å¤±è´¥")
                    failed_files.append(filename)

                del target_image, aligned
                if "processed" in locals():
                    del processed
                force_garbage_collection()

            except Exception as e:
                logging.info(f"  âœ— {filename}: å¤„ç†å¼‚å¸¸ - {e}")
                failed_files.append(filename)
                for v in ["target_image", "aligned", "processed"]:
                    if v in locals():
                        del locals()[v]
                force_garbage_collection()

        if progress_callback:
            progress_callback(100, "å¤„ç†å®Œæˆ")
        del reference_image
        force_garbage_collection()

        logging.info(f"å¢é‡å¯¹é½å®Œæˆ! æˆåŠŸå¯¹é½ {success_count}/{input_files_num} å¼ å›¾åƒ")
        logging.info(f"ä½¿ç”¨å‚è€ƒå›¾åƒ: {reference_filename}")
        logging.info(
            f"å¯¹é½ç®—æ³•: {'å¤šROIç²¾é…å‡†ï¼ˆä»…å¹³ç§»ï¼‰' if use_advanced_alignment else 'PHD2åœ†å¿ƒç®—æ³•'}"
        )
        if failed_files:
            head = ", ".join(failed_files[:5]) + (
                "..." if len(failed_files) > 5 else ""
            )
            logging.info(f"å¤±è´¥æ–‡ä»¶({len(failed_files)}): {head}")
        if method_stats:
            logging.info(
                "åœ†æ£€æµ‹æ–¹æ³•ç»Ÿè®¡: "
                + ", ".join([f"{k}={v}" for k, v in method_stats.items()])
            )
        logging.info(f"å½“å‰å†…å­˜ä½¿ç”¨: {get_memory_usage_mb():.1f} MB")
        if completion_callback:
            completion_callback(
                True, f"å¢é‡å¤„ç†å®Œæˆï¼æˆåŠŸå¯¹é½ {success_count}/{input_files_num} å¼ å›¾åƒ"
            )

    except Exception as e:
        import traceback

        err = f"å¢é‡å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}\n{traceback.format_exc()}"
        logging.error(err)
        if completion_callback:
            completion_callback(False, err)
    finally:
        force_garbage_collection()
